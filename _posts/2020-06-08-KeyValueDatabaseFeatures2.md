---
title:  NoSQL을 알아보자(7) - Key-Value 데이터베이스의 무결성
tag: [NoSQL, NoSQL을 알아보자, Key-Value Database]
comments: true
---
[지난 포스트](https://huved.github.io/2020/06/08/KeyValueDatabaseFeatures.html) 에서 Key-Value 데이터베이스는 Master-Slave 방식 또는 Masterless 방식을 이용해 확장성을 관리한다고 했다.

Master-Slave 구조에서는 쓰기 작업을 수행할 수 있는 서버는 Master 서버 뿐이다. 쓰기가 이뤄지면 Master 서버는 Slave 서버로 데이터를 복제하기 때문에 클러스터 안에 모든 서버들은 동일한 데이터를 가지게 된다.

하지만 Masterless 구조는 각각의 서버들이 모두 데이터를 쓸 수 있기 때문에 같은 작업이 동시에 발생할 가능성이 있다. 그리고 모든 서버에 데이터를 복제하는 Master-Slave과 달리 Masterless는 인접한 특정 수의 서버에만 데이터 복제를 수행하기 때문에 한 클러스터 안에 있는 서버들은 서로 다른 데이터를 가질 가능성도 존재한다.

그렇다면 Masterless 구조에서 데이터 중복 쓰기를 방지하는 방법과 오래된 데이터가 아닌 최신 데이터를 획득하는 방법은 무엇일까?

<br>
![Master-less](https://raw.githubusercontent.com/huved/huved.github.io/master/assets/images/nosql/img_masterless.png){: width="65%" height="65%"}{: .center}

예를 들어 5명의 유저가 동시에 롯데타워 롯데시네마에서 6월 8일 18시 아이언맨 F8 좌석을 예약한다고 가정해보자. 일반적인 상황에서 동시에 5개의 예약 요청을 전달하면 서버 1~5는 모두 예약 요청을 처리할 것이다. 그렇다면 좌석은 하나인데 예약은 5명이 되는 오류가 발생한다.

Key-Value 데이터베이스는 Key 값으로 이 같은 중복 오류를 해결할 수 있다. 특정 키의 요청은 정해진 한 서버에서만 처리하는 것이다.

중복되면 안되는 데이터인 ‘롯데타워 롯데시네마 6월 8일 18시 아이언맨 F8 좌석’을 키로 만들어서 해당 키를 한 서버에서만 관리하도록 하면 데이터 중복 문제도 일관성 문제도 해결할 수 있다.

<pre>
    lottetower:lottecinema:06081800:Ironman:F8
</pre>

위처럼 식별 가능한 고유 키를 만들어서 만약 이 키를 1번 서버에서 처리했다면 같은 좌석에 대한 모든 요청은 계속 1번 서버가 처리하는 방식이다. 이 같은 방식을 사용하면 동시에 5명이 같은 좌석 예약 요청을 하더라도 실제 처리는 한 서버에서 처리하기 때문에 중복 처리에서 안전하다.

그리고 데이터 읽기 요청도 1번 서버가 처리하기 때문에 복제 되지 않은 이전 데이터를 걱정할 필요 사라진다. Key-Value 데이터베이스는 위 방식을 통해 데이터 무결성을 유지할 수 있다. 

간단히 적용하는 방법은 Key 값을 해시 함수를 사용하여 숫자로 변환한 뒤 서버의 수로 나눠 나온 나머지 값을 통해 서버에 작업을 분배하는 방법이 있다.

